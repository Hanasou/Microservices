package auth

import (
	"context"
	"log"
	"net"

	"github.com/Hanasou/Microservices/users-service/src/authpb"
	"google.golang.org/grpc"
)

type server struct{}

func (*server) CreateUser(ctx context.Context, req *authpb.CreateUserRequest) (*authpb.CreateUserResponse, error) {
	return nil, nil
}

// TODO: Generate some gRPC code for an AddUserRequest

// Auth generates an AuthResponse from an AuthRequest
func (*server) Auth(ctx context.Context, req *authpb.AuthRequest) (*authpb.AuthResponse, error) {
	username := req.GetUsername()

	// TODO: Verify Password

	accessToken, refreshToken, err := GenTokens(username)
	if err != nil {
		log.Println("Error in Auth: Could not generate tokens")
		return nil, err
	}

	response := &authpb.AuthResponse{
		AccessToken:  accessToken,
		RefreshToken: refreshToken,
	}
	return response, nil
}

func (*server) Refresh(ctx context.Context, req *authpb.RefreshRequest) (*authpb.RefreshResponse, error) {
	username := req.GetUsername()
	refreshToken := req.GetRefreshToken()

	// TODO: Verify refresh token
	jwtKey, err := VerifyToken(refreshToken)
	if err != nil {
		log.Println("Error in verifying token")
		return nil, err
	}
	accessToken, err := RefreshToken(username, jwtKey)
	if err != nil {
		log.Println("Error in Refresh: Could not get new access token")
		return nil, err
	}

	response := &authpb.RefreshResponse{
		AccessToken: accessToken,
	}
	return response, nil
}

// BootstrapServer sets up our gRPC server
func BootstrapServer() (*net.Listener, *grpc.Server, error) {
	lis, err := net.Listen("tcp", "0.0.0.0:50051")
	if err != nil {
		log.Fatalln("Failed to listen", err)
	}
	log.Println("Connection established")

	// New server
	s := grpc.NewServer()
	// Register the service
	// This is defined in the autogenerated code
	// Right now we're just using an empty server struct, we'll add stuff to it later
	authpb.RegisterAuthServiceServer(s, &server{})

	// Start the server in a seperate goroutine
	go func() {
		log.Println("Server established. Accepting requests.")
		if err := s.Serve(lis); err != nil {
			log.Fatalln("Failed to serve", err)
		}
	}()

	return &lis, s, nil
}
